<head><link href="normalize.css" rel="stylesheet" type="text/css"/><link href="main.css" rel="stylesheet" type="text/css"/></head><body><div class="article-and-toc"><div class="toc-container"><div class="table-of-contents"><h1>Contents</h1><ol><li>Background<ol><li>The Future of Programming</li><li>Show, Don&rsquo;t Tell: Programming by Demonstration</li></ol></li><li>Paraspace: Exploring Programming by Demonstration in Mixed Reality<ol><li>Manipulating the Environment</li><li>Programming by Demonstration<ol><li>Behaviors: Programs in Paraspace</li><li>The Programming Oven: Creating Paraspace Behaviors by Demonstration<ol><li>Viewing Behaviors</li><li>Editing Behaviors</li></ol></li></ol></li><li>Ambiguities, Assumptions, Inferences, and Consequences</li></ol></li><li>Collaboration</li><li>Open Questions and Future Directions</li></ol></div></div><article><header><h1>Paraspace: Collaborative Programming in Mixed Reality</h1><p class="author">by Julian Ceipek</p></header><div class="body"><p><em>Programming</em> tends to conjure images of a lone genius &mdash; maybe a Zuckerberg or a Wozniak &mdash; hunched over a keyboard in a dark room somewhere, late at night, illuminated only by the glow of a computer monitor filled with arcane expressions. And while the truth is a lot messier, these fantasies <em>feel</em> true, and many programmers embrace them as part of their culture. Personally, I&rsquo;m not a fan.</p></div><div class="block-with-aside"><div class="body"><p>With the emergence of <em>affordable</em> virtual and augmented reality devices, we have a unique duty and opportunity to redesign many experiences from the ground up. A lot of stuff that works well on the small glowing rectangle of a computer, tablet, or phone screen doesn&rsquo;t make any sense in a more immersive environment. Designers are reimagining what it means to <a href="https://www.tiltbrush.com/" target="_blank">paint</a>, <a href="https://venturebeat.com/2016/10/03/limitless-lets-artists-create-animations-within-virtual-reality/" target="_blank">animate</a>, and <a href="http://fantasticcontraption.com/" target="_blank">play</a> in mixed reality. </p></div><div class="aside"><p>Augmented and Virtual reality have been around <a href="http://www.polygon.com/2016/10/26/13401128/25-vr-greatest-innovators" target="_blank">for a really long time</a>. What&rsquo;s special about <em>now</em> is really only that the technology has come far enough to be affordable.</p><p>Even more powerful than devices that deal in the virtual would be ways of augmenting our physical environments to create a new dynamic medium for thinking and doing.</p><p>Designers like Bret Victor <a href="http://worrydream.com/TheHumaneRepresentationOfThoughtTalk/" target="_blank">are working toward this laudable goal</a>, but it will likely be some time until these types of environments become commonplace. People have been thinking about them for a long time too:</p><div class="video-wrapper"><iframe width="1920" height="1080" src="https://www.youtube.com/embed/9HXp3s7x68o?modestbranding=0&amp;amp;showinfo=0&amp;amp;rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div></div></div><div class="body"><p>What might <em>programming</em> in mixed reality look like?</p><div class="video-wrapper"><iframe width="1920" height="1080" src="https://www.youtube.com/embed/lrOJyLD9Zf4?modestbranding=0&amp;amp;showinfo=0&amp;amp;rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div><p>This is a brief glimpse of Paraspace, the result of my one year attempt to explore that question as a master&rsquo;s student at the University of Southern California&rsquo;s <a href="https://cinema.usc.edu/interactive/" target="_blank">Interactive Media and Games Division</a>.</p></div><div class="body"><h2 class="heading">Background</h2><h3 class="heading">The Affordances of Mixed Reality</h3><h3 class="heading">The Future of Programming</h3><p>Many groups have experimented with alternate approaches to programming, including visual node-based and block-based programming models. These methods have found success in specific domains such as visual effects, robotics, and programming education.</p></div><div class="gallery"><div class="fig"><img src="images/nuke.png"/><p class="caption"><a href="https://www.foundry.com/products/nuke" target="_blank">Nuke</a>, node based programming for visual effects</p></div><div class="fig"><img src="images/labview.png"/><p class="caption"><a href="http://www.ni.com/labview/" target="_blank">LabView</a>, node based programming for robotics</p></div><div class="fig"><img src="images/scratch-jr.png"/><p class="caption"><a href="https://www.scratchjr.org/" target="_blank">Scratch Jr</a>, block-based programming on tablets for education</p></div></div><div class="body"><p>However, with few exceptions, they were designed for the same input methodologies as text-based programming environments and may not benefit from an additional spatial dimension. </p><h3 class="heading">Show, Don&rsquo;t Tell: Programming by Demonstration</h3><p>One programming methodology that does seem promising for creating programs in mixed reality is <em>Programming by Demonstration</em>. In traditional textual and node-based programming environments, programmers <em>tell</em> the computer what they want it to do via an indirect symbolic language. In Programming by Demonstration environments, they <em>show</em> the computer what they want to happen.</p><div class="aside"><p>Most of us could <em>show</em> a computer how to make a sandwich, but would struggle to <em>tell</em> one how to do it.</p><div class="video-wrapper"><iframe width="1920" height="1080" src="https://www.youtube.com/embed/KUB-aJXquUA?start=1166&amp;amp;end=1576&amp;amp;modestbranding=0&amp;amp;showinfo=0&amp;amp;rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div></div><p>Allen Cypher, one of the central proponents of this approach, <a href="http://acypher.com/wwid/FrontMatter/index.html#Introduction" target="_blank">writes</a></p><blockquote>The motivation behind Programming by Demonstration is simple and compelling: if a user knows how to perform a task on the computer, that should be sufficient to create a program to perform the task. It should not be necessary to learn a programming language like C or BASIC. Instead, the user should be able to instruct the computer to 	&ldquo;Watch what I do&rdquo;, and the computer should create the program that corresponds to the user&rsquo;s actions.</blockquote><p>Some of the most effective mixed reality environments (see, for example, <a href="http://fantasticcontraption.com/" target="_blank">Fantastic Contraption</a>) allow users to complete tasks using natural, embodied actions such as grabbing and moving objects with their hands. This directness lends itself well to Programming by Demonstration.</p><h2 class="heading">Paraspace: Exploring Programming by Demonstration in Mixed Reality</h2><p>Over the past year, I created <em>Paraspace</em> to explore how Programming by Demonstration might work in mixed reality. Unlike other Programming by Demonstration environments, Paraspace is collaborative and designed for the domain of visual simulations. Its target audience is visual artists who would like to experiment with behaviors but are limited by their lack of programming background. Paraspace welcomes one or more artists into a shared physical space that becomes a shared virtual space once they don Vive virtual reality headsets. The artists wield physical Vive controllers that allow them to construct a simple environment using virtual 3d primitive shapes they grab from an infinite virtual shelf. They can make this environment dynamic by creating simple movement and interaction behaviors for the shapes as they experiment, and they can pause and resume the simulation of these behaviors at any time, using a virtual timer with buttons akin to a VCR or video player.</p><p>My core design philosophy was one of consistency and conceptual simplicity; while some Programming by Demonstration systems infer user intent frequently, I wanted Paraspace to empower artists to concisely and unambiguously specify their intent. <a href="https://en.wikipedia.org/wiki/Stagecast_Creator" target="_blank">Stagecast Creator</a> and <a href="http://worrydream.com/#!/StopDrawingDeadFish" target="_blank">Stop Drawing Dead Fish</a> served as my main inspirations for this philosophy. In the following sections, I explore the design of Paraspace in the context of Programming by Demonstration.</p><h3 class="heading">Manipulating the Environment</h3><p>Before a Programming by Demonstration system can automate something, users must show the system how to do it, which means that they must also be able to do it manually. Paraspace provides three types of objects: cubes, spheres, and cylinders; and three hand-held tools with which artists can manipulate the environment: pliers, a vacuum cleaner, and a stamp. Each tool appears as a virtual tip for a Vive controller and uses the same interaction method: press and hold the trigger while moving the controller to manipulate the one object closest to the tip. The form of each tool matches its function:</p><ul><li>The pliers let artists move (translate and rotate) objects</li><li>The vacuum cleaner lets artists delete individual objects</li><li>The stamp lets artists duplicate objects</li></ul><p>While designing these tools, I needed to make carefully considered compromises between fluidity and precision to support the use of these tools for demonstrational programming without frustrating artists.</p><p>For example, an early version of the pliers allowed for freeform translation and rotation. Through testing, I discovered that this functionality prevented artists from making objects rotate without translating and vice-versa, because of the physical precision required. The current version of the pliers causes a rotation/translation gizmo to appear around the closest object. Grabbing from the center of the object allows the fluid free-form motion when arranging objects in the environment, while grabbing near the object endpoints or corners allows artists to translate or rotate an object along a single axis using an interface familiar to visual artists who have used 3D modeling or animation programs.</p><p>For the sake of precision, the vacuum cleaner only deletes one object at a time rather than continuously 	&ldquo;sucking&rdquo; objects as one might expect.</p><h2 class="heading">Programming by Demonstration</h2><p>The most important (and most challenging) aspect of any Programming by Demonstration system relates to how programs are created, how they are invoked, and how they infer meaning or intent from any inherent ambiguity in a user&rsquo;s actions. These concepts are all inextricably linked, so I&rsquo;ll explain the nature of programs in Paraspace before exploring how they are made and the design consequences of their invocation.</p><h3 class="heading">Behaviors: Programs in Paraspace</h3><p>In Paraspace, programs are called behaviors. Each behavior consists of a <em>situation</em> (an object configuration that must exist before the behavior can take effect), and a <em>consequence</em> (a sequence of manipulations that specifies the outcome of the behavior).</p><p>One example of a behavior might be:</p><ul><li>when a cube exists (situation), it should rotate a little bit (consequence).</li></ul><p>Another might be:</p><ul><li>when a cube and a sphere touch (situation), the cube should be deleted (consequence).</li></ul><p>Paraspace is a simulation environment; while the simulation is running, the system continuously performs all the behaviors that have valid situations. If there are multiple instances of the same situation in the environment, a single behavior will take effect for each one. For example, multiple cubes might all move at once because of a behavior that causes a cube to move if it exists. This contrasts with systems like <a href="http://acypher.com/wwid/Chapters/01Pygmalion.html" target="_blank">Pygmalion</a> and <a href="http://acypher.com/wwid/Chapters/16Mondrian.html" target="_blank">Mondrian</a>, which rely on users to manually <a href="http://acypher.com/wwid/Chapters/25Characterizing.html" target="_blank">invoke programs from a palette</a>.</p><h3 class="heading">The Programming Oven: Creating Paraspace Behaviors by Demonstration</h3><p>Programming by Demonstration systems handle program creation in a variety of different ways. Some early systems, like Eager and The Predictive Calculator, monitor the environment for repetitive actions. Chimera maintains a graphical history of everything that has happened and allows users to select part of that history to turn into a program. A more common approach is to <a href="http://acypher.com/wwid/Chapters/25Characterizing.html" target="_blank">manually turn on a recording</a> system for the duration of the demonstration, but this has the potential to clutter the context of the recording (the situation part of the behaviors in Paraspace). My favorite approach is Stagecast Creator&rsquo;s rule tool, which starts a recording and uses the immediate surroundings of the targeted object as the context. However, this solution loses much of its elegance and effectiveness in an environment without Stagecast Creator&rsquo;s two-dimensional grid.</p><p>Paraspace introduces the concept of a <em>programming oven</em>, a virtual appliance that is unaffected by the simulation and acts as a recording environment. Artists place objects inside the oven to establish a situation, and the oven automatically projects a copy of that situation above it. Every action artists perform on the projected objects is sequentially recorded as the consequence of the behavior specified by the situation inside the oven.</p><p>For example, to create a rule that makes cubes move along their up-axes, an artist would:</p><ol><li>Use the pliers tool to pick up a cube from the environment</li><li> <p>Drag the cube into the oven, and release it inside</p><p>(a projection of the cube will appear above the oven)</p></li><li>Move the pliers close to the projected cube to reveal the movement gizmo</li><li>Grab the upper arrow on the movement gizmo, move the cube up a bit, and release it</li></ol><p> The behavior exists immediately and can be said to have been 	&ldquo;baked&rdquo; into the supplied situation. Even if an artist removes or deletes the objects inside the oven, the behavior will persist.</p><h4 class="heading">Viewing Behaviors</h4><p>A potent criticism of many traditional programming environments is that they fail to &ldquo;show the data&rdquo; &mdash; programmers must imagine what a program will do or is doing, <a href="http://worrydream.com/#!/LearnableProgramming" target="_blank">even though this information should be readily available</a>. Paraspace is by no means perfect in this regard, but it does provide some facilities for viewing the consequences of authored behaviors. Whenever the oven contains any objects, the oven plays a miniature looping simulation of the those objects next to the modifiable projection. This preview gives artists a faster feedback loop while creating behaviors before testing them in the larger environment.</p><p>While Paraspace does support individual behavior viewing via the oven, it currently fails to provide a mechanism for viewing historically created behaviors; artists must remember which situations have corresponding consequences to view or edit them. Since Paraspace only supports two types of situations at present, this is less of a problem than it otherwise might be (with three unique object types, artists can only create ten unique situations).</p><h4 class="heading">Editing Behaviors</h4><p>Paraspace&rsquo;s facilities for editing existing behaviors are quite limited, which is acceptable only because the behaviors tend to be very simple. While artists can easily add additional manipulations to the behavior corresponding to the situation within the oven, their only option for changing earlier manipulations is to reset the consequence associated with the situation inside the oven using the oven&rsquo;s single &lsquo;X&rsquo; button.</p><h3 class="heading">Ambiguities, Assumptions, Inferences, and Consequences</h3><p>Programming by Demonstration systems are prone to ambiguity, and Paraspace is no exception. In general, I tried to choose the most obvious general interpretation of each ambiguous case, but unexpectedly, that wasn&rsquo;t always possible. Consider the case of a red cube in the oven. The most specific interpretation for the corresponding situation would be: 	&ldquo;this specific cube in the current orientation and position,&rdquo; but that interpretation is clearly over-specified and useless. Conversely, the interpretation 	&ldquo;any object in any position and orientation&rdquo; is likely too general. Instead, I chose the relatively intuitive 	&ldquo;any cube&rdquo; interpretation, which is powerful in its generality without applying to everything.</p><p>If the objects in Paraspace had a more diverse set of properties, the choice would no longer be so obvious. For example, if objects could have different colors, should placing a red cube in the oven create a behavior that applies to black cubes? Each option seems equally desirable in different situations; ideally, the artist creating the behavior should be able to specify their desired interpretation. How they could do so is an open question.</p><p>Multi-object situations introduce additional ambiguities. When two objects touch in the oven, the obvious interpretation is that the situation should apply whenever those types of objects touch. However, I was unable to determine a meaningful interpretation of two objects present in the oven but not touching. Should that situation imply something about the distance between the objects? The least consistent aspect of Paraspace is that it only understands situations in which the oven contains a single object or two touching objects, and it ignores all other situations.</p><p>The consequence of a behavior is seemingly well-specified because it applies to a copy of the behavior&rsquo;s situation, but recall that a behavior needs to apply to situations that are more general than the specific configuration of objects in the oven. Does moving a projected cylinder upwards in the oven make all affected cylinders in the environment move upwards in world space or in local space? For the sake of greater expressivity, Paraspace interprets all movements in local space. I subtly reinforced this idea throughout Paraspace&rsquo;s design: moving the pliers close to an object makes a local transform gizmo appear around the object, and placing an object in the oven makes its initial projection appear above the oven with its global rotation removed.</p><h2 class="heading">Collaboration</h2><p>Very few programming environments give any thought to collaborative programming. In almost all cases, collaboration is an afterthought handled through clunky external version control systems that often require manual intervention to combine parts of programs written by different authors. I think mixed reality environments have the potential to dramatically improve collaborative programming. While designing Paraspace, I considered collaboration from the outset. Artists occupy a shared virtual working environment and can see minimalist googley-eyed avatars of each other, inspired by the <a href="https://youtu.be/lGUmTQgbiAY?t=1124" target="_blank">experiments at Daydream Labs</a>.</p><p>In one sense, collaboration in Paraspace is very successful: one artist can freely set up a simulation while another creates behaviors for its components. This situation vastly improves on the iteration time seen in most contemporary programming environments and reduces context switching for each artist.</p><p>However, supporting collaboration made the design of many elements in Paraspace much more difficult while resulting in a degraded user experience overall. For example, user interfaces should allow users to easily recover from mistakes, but the standard solution&mdash;undo&mdash;is poorly defined in a multi-user system. Global undo is the obvious approach <a href="http://mi-lab.org/projects/undo-on-large-interactive-surfaces/" target="_blank">but fails to meet user expectations</a>. Since developing robust multi-user undo seems to be case-dependent and equivalent in scope to a thesis project, I chose not to implement an undo system.</p><p>I made a similar concession to spatial navigation in Paraspace. While mixed reality tools like <a href="https://www.tiltbrush.com/" target="_blank">Tilt Brush</a> allow users to resize the environment and move themselves through it without moving physically, I chose to maintain a consistent environment scale and to maintain a direct mapping between an artist&rsquo;s location in physical and virtual space. I made this decision because I wanted the artists to communicate verbally in a shared physical space without colliding with each other, while simultaneously maintaining agency over their movement through the space to combat VR sickness. An obvious alternative would be to have a separate physical space for each artist and to transmit artist locations and communications over the internet. Beyond creating massively more complex technical issues, that approach would have created a host of new design issues related to personal space in mixed reality environments.</p><p>In practice, Paraspace&rsquo;s programming oven metaphor restricts program editing to a single behavior at a time, but in principle, concurrent editing of separate behaviors might be worth exploring. I suspect that it would be less chaotic than concurrent editing in a text-based programming environment. </p><h2 class="heading">Open Questions and Future Directions</h2><p>Paraspace sets the groundwork for a novel alternative method for programming in mixed reality, based in the philosophy of Programming by Demonstration. It introduces a set of consistent direct manipulation tools for manipulating a collaborative virtual environment and establishes a framework for using these tools in the context of a 	&ldquo;programming oven&rdquo; that empowers visual artists to create behaviors for objects in the environment while reducing iteration times.</p><p>Nonetheless, many open questions stand in the way of Programming by Demonstration becoming a truly viable approach for creating sophisticated virtual environments in mixed reality. As mentioned earlier, adding more properties to objects would require more sophisticated methods for users to communicate their intent in the case of ambiguities. That ability would then allow the system to support objects with mutable state such as speed or acceleration. It would also remove Paraspace&rsquo;s constraint on how few types of situations may exist.</p><p>In an early version of Paraspace, I allowed artists to create behaviors that took place over longer periods of time than a single frame, but that changed their expectations about whether behaviors should operate in local or global space while raising a host of design issues such as what should happen if an object is involved in a collision while completing a previous behavior. Future explorations might tackle these problems.</p><p>For scope reasons, I purposely chose to ignore abstraction, the sequencing of behaviors, and the creation of control structures like loops and conditionals, but a more sophisticated programming environment would need these or equivalent facilities.</p><p>Finally, if a Programming by Demonstration system were used to create more interesting and complex mixed reality simulations than the ones possible in Paraspace, it would need more powerful mechanisms for viewing and debugging behaviors. <a href="https://en.wikipedia.org/wiki/Stagecast_Creator" target="_blank">Stagecast Creator</a> has some powerful capabilities that might serve as a useful starting point.</p></div></article></div></body>
